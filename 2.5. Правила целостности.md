
MySQL позволяет задавать условия, которым должны удовлетворять данные в базе. Программист задает условие, а сервер обеспечивает проверку при любом изменении данных. Такие условия называются **_правилами целостности._**

В MySQL поддерживаются следующие правила целостности, которые накладывают ограничения на данные в пределах одной таблицы:

1. Запрет неопределенных значений (not null)
2. Уникальность значения (unique)
3. Первичный ключ (Primary key)

Кроме того, для ограничения ссылочной целостности существуют внешние ключи (foreign key).


## Запрет неопределенных значений (NOT NULL)

_**NULL**_ - это специальное значение, которое используется в SQL для обозначения отсутствия какого-либо значения в ячейке таблицы (! не равно 0).

**_NOT NULL_** - проверка на непустое значение.

Обычно ограничения задаются при создании таблиц. Но в дальнейшем их можно изменять, удалять или временно запрещать при помощи соответствующих команд СУБД.

На примере создания таблицы _**patients**_ давайте выставим столбцу _**full_name**_ ограничение на пустое значение - после типа данных пропишем NOT NULL:

```sql
CREATE TABLE patients
(   
    full_name VARCHAR(100) NOT NULL,
    sex CHAR(1),
    birth_date DATE,
    oms_num BIGINT
);
```

Если таблица уже создана - применяем команду _**ALTER**_ для изменения атрибутов столбца со следующим синтаксисом:

```sql
ALTER TABLE название_таблицы
CHANGE текущее_название_столбца новое_название_столбца новый_тип_столбца новые_атрибуты_столбца;
```

На нашем примере: 

```sql
ALTER TABLE patients CHANGE full_name full_name VARCHAR(100) NOT NULL;
```



Теперь, если мы решим вставить новую строку в таблицу _**patients**_ с незаполненным _**full_name,**_ то СУБД выдаст нам ошибку - поле full_name не может содержать NULL значение. Проиллюстрируем работу ограничения NOT NULL на картинке:

![[2.5. pic1.png]]



### Добавьте ограничение для уже существующей таблицы- запрет на пустые значения в таблице _**med_area**_ для поля **_area_num_** (используйте ALTER)

_Скрипт таблицы:_

```sql
CREATE TABLE med_area
(
    area_num TINYINT,
    area_address VARCHAR(1000)
);
```


```sql
ALTER TABLE med_area
CHANGE area_num area_num TINYINT NOT NULL;
```



## Уникальность значения (UNIQUE)

Согласно правилу **_UNIQUE,_** в таблице не может существовать двух строк с одинаковыми значениями столбца или набора столбцов. При этом неопределенные значения не считаются одинаковыми, то есть две или более строк со значениями NULL могут быть у столбца/столбцов, заявленные как UNIQUE.

В случае с номером полиса _**oms_num**_ в таблице **_patients_** можно применить данное правило. Номер полиса должен быть уникален, но может иметь пустые значения (пациент еще не оформил ОМС, или обслуживается без него).

При создании таблицы UNIQUE указывается вот так:

```sql
CREATE TABLE patients
(
    full_name VARCHAR(100) NOT NULL,
    sex CHAR(1),
    birth_date DATE,
    oms_num BIGINT UNIQUE
);
```

Проиллюстрируем работу ограничения:

![[2.5. pic2.png]]



### Добавьте ограничение UNIQUE на столбец _**oms_num**_ в уже созданной таблице **_patients_**.

_скрипт таблицы patients:_

```sql
CREATE TABLE patients
(
    full_name VARCHAR(100) NOT NULL,
    sex CHAR(1),
    birth_date DATE,
    oms_num BIGINT
);
```


```sql
ALTER TABLE patients
CHANGE oms_num oms_num BIGINT UNIQUE;
```



## Первичный ключ (PRIMARY KEY)

Первичный ключ — поле или комбинация полей в таблице, которое позволяет однозначно идентифицировать каждую запись в ней. 

Значение в столбце считается _**первичным ключом**_, если оно непустое (NOT NULL) и уникально в пределах столбца данной таблицы (UNIQUE). Первичный ключ может быть составным и представлять собой комбинацию столбцов. 

Создать первичный ключ можно _**при создании таблицы**_ двумя способами:

1) PRIMARY KEY указывается в атрибутах таблицы, в скобках указывается столбец или столбцы(через запятую), которые будут входить в первичный ключ.

```sql
CREATE TABLE med_area
(
    area_num TINYINT,
    area_address VARCHAR(1000) ,
    PRIMARY KEY (area_num)
);
```

2)  PRIMARY KEY указывается в атрибутах столбца (данный синтаксис актуален только, если один столбец будет входить в первичный ключ)

```sql
CREATE TABLE med_area
(
    area_num TINYINT PRIMARY KEY,
    area_address VARCHAR(1000)
);
```

Добавить первичный ключ _**в уже существующую таблицу**_ можно следующим образом:

```sql
ALTER TABLE med_area ADD PRIMARY KEY(area_num);
```



## Для чего нужен PRIMARY KEY?

Первичный ключ, это ограничение, которое позволяет нам однозначно идентифицировать строки в таблице. Объявив его, мы знаем, что система не позволит нам задублировать информацию.

Проиллюстрируем работу данного ограничения на картинке:

![[2.5. pic3.png]]



Для изучения дальнейших шагов опишем как добавить не только ограничение для столбца или таблицы, но и новый столбец.

## Добавление столбца

Для добавления столбца используется следующий синтаксис:

```sql
ALTER TABLE название_таблицы
ADD COLUMN название_нового_столбца тип_нового_столбца атрибуты_нового столбца;
```

Давайте добавим новый столбец - номер карты пациента в существующую таблицу _**patients**_:

```sql
ALTER TABLE patients
ADD COLUMN card_num INT;
```



## Внешний ключ (FOREIGN KEY)

Внешний ключ - это поле или набор полей, перечисленных через запятую, _**количество и типы данных**_ которых совпадают с **_количеством и типом данных полей_** первичного ключа в родительской таблице.

Синтаксис определения внешнего ключа (применимый только в рамках создания таблицы):

```sql
CREATE TABLE название_таблицы(
<блок описания полей>

,FOREIGN KEY (название_поля) REFERENCES название_родительской_таблицы(название_поля_родит_таблицы)
);
```

_**FOREIGN KEY**_ - оператор для создания внешнего ключа

название_поля - название поля создаваемой таблицы, которое будет ссылаться на поле из родительской таблицы

_**REFERENCES**_  - ключевое слово, после которого указывается имя связанной(родительской) таблицы.

_**название_родительской_таблицы**_ - название связанной(родительской) таблицы.

_**название_поля_родит_таблицы**_ - название поля связанной(родительской) таблицы.

Сразу на примере с Пациентами и Участками разберем создание внешнего ключа. 

Каждый пациент привязан к определенному участку по месту проживанию, поэтому было бы целесообразно связать эти две таблицы и для каждого пациента проставить номер участка. Для этого сначала необходимо создать в таблице _**patients**_ новое поле - **_area_num_**, в которой будут храниться номера участков.



### Добавьте в таблицу _**patients**_ новое поле - _**area_num**_ с типом _**TINYINT.**_


```sql
ALTER TABLE patients
ADD COLUMN area_num TINYINT
```



Создание внешнего ключа обеспечивает ссылочную целостность, то есть номер участка, который будет проставлен у пациента - должен представлять собой номер, существующего в таблице _**med_area,**_ участка. В этом случае таблица с участками - родительская, таблица с пациентами - дочерняя.

Создание внешнего ключа при создании дочерней таблицы (на примере таблицы Пациентов):

```sql
CREATE TABLE patients
(
    full_name VARCHAR(100) NOT NULL,
    sex CHAR(1),
    birth_date DATE,
    oms_num BIGINT UNIQUE,
    card_num INT,
    area_num TINYINT, 
    FOREIGN KEY (area_num) REFERENCES med_area(area_num)
);
```

При добавлении FOREIGN KEY в уже существующую таблицу _**patients**_ используем следующий скрипт:

```sql
ALTER TABLE patients ADD FOREIGN KEY (area_num) REFERENCES med_area(area_num);
```

_**! Обратите внимание, что тип данных поля area_num в родительской и дочерней таблице должны совпадать.**_

Наглядно связь между таблицами можно увидеть на диаграмме:

![[2.5. pic4.png]]



### _**В каком из перечисленных столбцов можно хранить пустые (NULL) значения?**_


 -  [x] exam_id int unique
 -  [x] exam_id int
 -  [ ] exam_id int not null



### _**Какими характеристиками будет обладать столбец, который укажут как PRIMARY KEY(первичный ключ)?**_


 -  [ ] Ничего из перечисленного
 -  [ ] NOT NULL
 -  [x] NOT NULL и UNIQUE
 -  [ ] UNIQUE